{
  "javascript / typescript": [
    {
      "question": "null vs undefined",
      "answer": ""
    },
    {
      "question": "What's Generic type?",
      "answer": ""
    },
    {
      "question": "What's Partial type?",
      "answer": ""
    },
    {
      "question": "What's Required type?",
      "answer": ""
    },
    {
      "question": "What's Union type?",
      "answer": "function printId(id: number | string) { }"
    },
    {
      "question": "What's Intersection type?",
      "answer": "Animal & { honey: boolean }"
    }
  ],
  "html / css": [
    {
      "question": "What's a CSS transition & how to define it?",
      "answer": "Via 'transition' shorthand property or transition-[property], transition-duration,..."
    },
    {
      "question": "What's a CSS animation & how to define it?",
      "answer": "Via @keyframes, animation-name, animation-duration, animation-delay,..."
    },
    {
      "question": "CSS transitions vs animations",
      "answer": "Transitions have no intermediate steps while animations do. Transitions can run only once while animations can be repeated forever. Transitions require a trigger to run (e.g. mouse hover) while animations do not. Transitions are best for creating a simple change from one state to another while animations are best for creating a complex series of movements."
    },
    {
      "question": "em vs rem",
      "answer": ""
    },
    {
      "question": "Do you often use !important? If so, why?",
      "answer": ""
    }
  ],
  "scss": [
    {
      "question": "Why do you use it?",
      "answer": ""
    },
    {
      "question": "What's inheritance & how to define it?",
      "answer": "@extend is used to share a set of CSS properties from one selector to another"
    },
    {
      "question": "What's a mixin & how to define it?",
      "answer": "@mixin is used to define reusable styles"
    },
    {
      "question": "What's a function & how to define it?",
      "answer": "Define reusable complex operations on Scss values. @function function-name($param1, $param2) { }"
    },
    {
      "question": "@extend vs @mixin",
      "answer": "@mixin supports arguments while @extend does not. @extend used to express a relationship between semantic classes (code meaning) e.g. .error--serious is a type of error => should extend .error"
    }
  ],
  "angular": [
    {
      "question": "How many types of directives are there? And what are they?",
      "answer": "A component directive is also called component (component has a template while a directive does not). An attribute directive changes behavior / appearance of an element (e.g. NgStyle, NgClass). A structural directive manipulates the DOM (ngIf, ngFor)"
    },
    {
      "question": "What's a Guard & how to use it?",
      "answer": "To authorize routes using CanActivate/ CanDetactive"
    },
    {
      "question": "What's an Interceptor? How to handle API errors?",
      "answer": ""
    },
    {
      "question": "How to send data to a child component?",
      "answer": ""
    },
    {
      "question": "How to send events to the parent from a child component? Any other ways?",
      "answer": ""
    },
    {
      "question": "How to send events to multiple components at the same time?",
      "answer": ""
    },
    {
      "question": "What's change detection? How to notify Angular of a change if Angular cannot detect it?",
      "answer": "Use NgZone or ChangeDetectorRef"
    },
    {
      "question": "What's a standalone component?",
      "answer": ""
    },
    {
      "question": "Promise vs Observable",
      "answer": "Promise: promise to call back later when the results are ready => 'one & done'. Observable: normally returned by HTTP methods, stream of events that can be processed with array-like operators"
    },
    {
      "question": "How to unsubscribe from an Observable?",
      "answer": "One manual way & one automatic way"
    }
  ],
  "rxjs": [
    {
      "question": "Operator 'map'",
      "answer": ""
    },
    {
      "question": "Operator 'of'",
      "answer": ""
    },
    {
      "question": "Operator 'first'",
      "answer": "Get 1st value"
    },
    {
      "question": "Operator 'last'",
      "answer": "Get last value"
    },
    {
      "question": "Operator 'single'",
      "answer": "Emit only one value from the observable that satisfies a condition. Otherwise, emit an error"
    },
    {
      "question": "Operator 'take'",
      "answer": "Take only the first x values emitted by the source Observable"
    },
    {
      "question": "Operator 'takeUntil'",
      "answer": "Take the values emitted by the source Observable until a notifier Observable emits a value"
    },
    {
      "question": "Operator 'takeWhile'",
      "answer": "Take values emitted by the source Observable as long as each value satisfies a condition"
    },
    {
      "question": "Operator 'skip'",
      "answer": "Skip the first x values emitted by the source Observable"
    },
    {
      "question": "Operator 'skipLast'",
      "answer": "Skip the last x values emitted by the source Observable"
    },
    {
      "question": "Operator 'skipUntil'",
      "answer": "Skip values emitted by the source Observable until a notifier Observable emits a value"
    },
    {
      "question": "Operator 'skipWhile'",
      "answer": "Skip all values emitted by the source Observable as long as a specified condition is true"
    },
    {
      "question": "Operator 'throttle'",
      "answer": "Emit a value from the source Observable, then ignore subsequent values for a duration determined by another Observable, then repeat this process"
    },
    {
      "question": "Operator 'throttleTime'",
      "answer": "Emit a value from the source Observable, then ignore subsequent values for duration in milliseconds, then repeat this process"
    }
  ]
}
