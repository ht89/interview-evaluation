{
  "javascript / typescript": [
    {
      "id": "null vs undefined",
      "answer": ""
    },
    {
      "id": "Generic type",
      "answer": ""
    },
    {
      "id": "Partial type",
      "answer": ""
    },
    {
      "id": "Required type",
      "answer": ""
    },
    {
      "id": "Union type",
      "answer": "function printId(id: number | string) { }"
    },
    {
      "id": "Intersection type",
      "answer": "Animal & { honey: boolean }"
    }
  ],
  "html / css": [
    {
      "id": "CSS transition & how to define it",
      "answer": "Via 'transition' shorthand property or transition-[property], transition-duration,..."
    },
    {
      "id": "CSS animation & how to define it",
      "answer": "Via @keyframes, animation-name, animation-duration, animation-delay,..."
    },
    {
      "id": "CSS transitions vs animations",
      "answer": "Transitions have no intermediate steps while animations do. Transitions can run only once while animations can be repeated forever. Transitions require a trigger to run (e.g. mouse hover) while animations do not. Transitions are best for creating a simple change from one state to another while animations are best for creating a complex series of movements."
    },
    {
      "id": "em vs rem",
      "answer": ""
    },
    {
      "id": "When to use !important",
      "answer": ""
    }
  ],
  "scss": [
    {
      "id": "Inheritance & how to define it",
      "answer": "@extend is used to share a set of CSS properties from one selector to another"
    },
    {
      "id": "Mixin & how to define it",
      "answer": "@mixin is used to define reusable styles"
    },
    {
      "id": "Function & how to define it",
      "answer": "Define reusable complex operations on Scss values. @function function-name($param1, $param2) { }"
    },
    {
      "id": "@extend vs @mixin",
      "answer": "@mixin supports arguments while @extend does not. @extend used to express a relationship between semantic classes (code meaning) e.g. .error--serious is a type of error => should extend .error"
    }
  ],
  "angular": [
    {
      "id": "Directives",
      "answer": "A component directive is also called component (component has a template while a directive does not). An attribute directive changes behavior / appearance of an element (e.g. NgStyle, NgClass). A structural directive manipulates the DOM (ngIf, ngFor)"
    },
    {
      "id": "Guard & how to use it",
      "answer": "To authorize routes using CanActivate/ CanDetactive"
    },
    {
      "id": "Interceptor & when to use it",
      "answer": ""
    },
    {
      "id": "How to send data to a child component",
      "answer": ""
    },
    {
      "id": "How to send events to the parent from a child component",
      "answer": ""
    },
    {
      "id": "How to send events to multiple components simultaneously",
      "answer": ""
    },
    {
      "id": "Change detection & how to notify Angular of a change",
      "answer": "Use NgZone or ChangeDetectorRef"
    },
    {
      "id": "Standalone component",
      "answer": ""
    },
    {
      "id": "Promise vs Observable",
      "answer": "Promise: promise to call back later when the results are ready => 'one & done'. Observable: normally returned by HTTP methods, stream of events that can be processed with array-like operators"
    },
    {
      "id": "Unsubscribe from an Observable",
      "answer": "One manual way & one automatic way"
    }
  ],
  "rxjs operators": [
    {
      "id": "map",
      "answer": ""
    },
    {
      "id": "of",
      "answer": ""
    },
    {
      "id": "first",
      "answer": "Get 1st value"
    },
    {
      "id": "last",
      "answer": "Get last value"
    },
    {
      "id": "single",
      "answer": "Emit only one value from the observable that satisfies a condition. Otherwise, emit an error"
    },
    {
      "id": "take",
      "answer": "Take only the first x values emitted by the source Observable"
    },
    {
      "id": "takeUntil",
      "answer": "Take the values emitted by the source Observable until a notifier Observable emits a value"
    },
    {
      "id": "takeWhile",
      "answer": "Take values emitted by the source Observable as long as each value satisfies a condition"
    },
    {
      "id": "skip",
      "answer": "Skip the first x values emitted by the source Observable"
    },
    {
      "id": "skipLast",
      "answer": "Skip the last x values emitted by the source Observable"
    },
    {
      "id": "skipUntil",
      "answer": "Skip values emitted by the source Observable until a notifier Observable emits a value"
    },
    {
      "id": "skipWhile",
      "answer": "Skip all values emitted by the source Observable as long as a specified condition is true"
    },
    {
      "id": "throttle",
      "answer": "Emit a value from the source Observable, then ignore subsequent values for a duration determined by another Observable, then repeat this process"
    },
    {
      "id": "throttleTime",
      "answer": "Emit a value from the source Observable, then ignore subsequent values for duration in milliseconds, then repeat this process"
    }
  ]
}
